# -*- coding: utf-8 -*-
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

from vortex_radioss.radioss.RadiossReader import RadiossReader
from lasso.dyna.d3plot import D3plot
import numpy as np
from lasso.dyna.array_type import ArrayType
import os

from vortex_radioss.radioss.RadiossTHReader import RadiossTHReader

import time
import math

start=time.time()
d3plot = D3plot()

def sequential(input_array):
    "Radioss puts a load of zeros at the end, increase by 1 to keep Primer happy for sequential node numbering"    
 
    zero_num = max(input_array)
    output = []
    for i in input_array:
        if i != 0:
            output.append(i)
        else:
            zero_num +=1
            output.append(zero_num)
    output = np.array(output)
    return output 

def generate_sorter(input_array):
    __index_tracker = [i for i in range(0,len(input_array))]
    _index_tracker = [y for x, y in sorted(zip(list(input_array), list(__index_tracker)))]      
    index_tracker = [0] * len(_index_tracker)
    
    for i_a, a in enumerate(_index_tracker):
        index_tracker[a] = i_a    
        
    return _index_tracker

def apply_sorter(input_array, tracker_array):
    
    # old index to new index
    output_array = [0] * len(input_array)
    for i_a, a in enumerate(tracker_array):
        output_array[i_a] = input_array[tracker_array[i_a]]
    return np.array(output_array)

def A_2_D(file_stem):
    
    if os.path.isfile(file_stem + "d3plot"):
        return True


    #d3 = D3plot("D:/Yaris_Mega_Casting/A001b/FMVSS305_R/28/DynaOpt.ptf")
    #print(d3.arrays["part_titles"].dtype)
    #fde

    state_index = 1
    file_list = []
    
    while(True):
        file_name = file_stem + "A" + '%3.3i' % state_index
        if os.path.isfile(file_name):
            file_list.append(file_name)
            state_index += 1
        else:
            break
    
    
    node_acceleration               = []
    node_velocity                   = []
    node_displacement               = []
    original_node_coordinates       = None
    
    element_beam_is_alive           = []
    
    element_shell_thickness         = []
    element_shell_specific_energy   = []
    element_shell_stress            = []
    element_shell_is_alive          = []
    
    element_solid_is_alive          = []
    
    part_names                      = []
    
    timesteps                       = []
    
    rr_th = RadiossTHReader(file_stem + "T01")    
    
    states = 0
    for file in file_list:
        print(states)
        states +=1
        rr = RadiossReader(file) 
        
        if states == 1:
            shell_ids_tracker = generate_sorter(sequential(rr.arrays["element_shell_ids"]))
            
            original_node_coordinates = rr.arrays["node_coordinates"]
    
        "Node Updates"
        node_acceleration.append(rr.arrays["node_acceleration"])
        node_velocity.append(rr.arrays["node_velocity"])
           
        node_displacement.append(rr.arrays["node_coordinates"])
        
        "Beam Updates"    
        
        element_beam_is_alive.append((rr.arrays["element_beam_is_alive"]).astype("<f"))
        
        "shell updates"
        if "element_shell_thickness" in rr.arrays:
            element_shell_thickness.append(apply_sorter(rr.arrays["element_shell_thickness"], shell_ids_tracker))
        
        _element_shell_stress = np.zeros(shape=(rr.raw_header["nbFacets"], 2, 6))
        
        _element_shell_stress[:, 0, 0] = rr.arrays["Stress (upper)"][:, 0]
        _element_shell_stress[:, 0, 1] = rr.arrays["Stress (upper)"][:, 1]
        _element_shell_stress[:, 0, 2] = np.zeros(shape=(rr.raw_header["nbFacets"]))
        _element_shell_stress[:, 0, 3] = rr.arrays["Stress (upper)"][:, 2]
        _element_shell_stress[:, 0, 4] = rr.arrays["Stress (upper)"][:, 2]
        _element_shell_stress[:, 0, 5] = np.zeros(shape=(rr.raw_header["nbFacets"]))    
        
        _element_shell_stress[:, 1, 0] = rr.arrays["Stress (lower)"][:, 0]
        _element_shell_stress[:, 1, 1] = rr.arrays["Stress (lower)"][:, 1]
        _element_shell_stress[:, 1, 2] = np.zeros(shape=(rr.raw_header["nbFacets"]))
        _element_shell_stress[:, 1, 3] = rr.arrays["Stress (lower)"][:, 2]
        _element_shell_stress[:, 1, 4] = rr.arrays["Stress (lower)"][:, 2]
        _element_shell_stress[:, 1, 5] = np.zeros(shape=(rr.raw_header["nbFacets"]))     
        element_shell_stress.append(apply_sorter(_element_shell_stress, shell_ids_tracker))
    
        element_shell_is_alive.append(apply_sorter(rr.arrays["element_shell_is_alive"], shell_ids_tracker).astype("<f"))
        
        "Calculate element shell areas"
        
        if part_names == []:
            nc=[]    
            for i in rr.arrays["element_shell_node_indexes"]  :
                nc_tmp=[]
                for j in i:
                    nc_tmp.extend(rr.arrays["node_coordinates"][j])
                nc.append(nc_tmp)

            element_shell_area=[]
            for _nc in nc:
            
                # The use of calculating node_n means that this method conventiently works for tria's and quads
                node_n=int((len(_nc)/3))
                
                ux = _nc[0]-_nc [6]; uy = _nc[1]-_nc [7];  uz = _nc[2]-_nc [8]
                vx = _nc[(node_n-1)*3]-_nc [3]; vy = _nc[((node_n-1)*3)+1]-_nc [4];  vz = _nc[((node_n-1)*3)+2]-_nc [5]
                
                i = uy*vz - uz*vy; j = uz*vx - ux*vz; k = ux*vy - uy*vx;
                area=math.sqrt((i*i)+(j*j)+(k*k))*0.5
                element_shell_area.append(area)
                if node_n==4:
                    length=math.sqrt(area)
                if node_n==3:
                    length= math.sqrt((area*4)/math.sqrt(3))
    
        "Solid Updates"
        
        element_solid_is_alive.append((rr.arrays["element_solid_is_alive"]).astype("<f"))
        
        "Part Updates"
        
        "Extract and map part mass from TH file"

        if part_names == []:
            part_mass = []
            for part_name in rr.raw_arrays["pTextA"]:
                part_name = part_name[10:].strip()
                part_names.append(part_name)
                if part_name in rr_th.array["part"]:
                    part_mass.append(rr_th.array["part"][part_name]["MASS"][0][0])
                else:
                    part_mass.append(0)
                    
            if "element_shell_thickness" in rr.arrays:        
                part_shell_volume_tmp=[[] for item in range(0,len(rr.raw_arrays["pTextA"]))]
                
                for i in range (0, rr.raw_header["nbFacets"]):
                    part_shell_volume_tmp[rr.arrays["element_shell_part_indexes"][i]].append(element_shell_area[i] * rr.arrays["element_shell_thickness"][i])
                part_volume=[sum(item) for item in part_shell_volume_tmp]                
                
                part_density = [a/b if b!= 0 else 0 for a,b in zip(part_mass, part_volume)]
            
        if "element_shell_thickness" in rr.arrays:
            element_shell_specific_energy.append(apply_sorter([rr.arrays["element_shell_specific_energy"][i_shell]/part_density[rr.arrays["element_shell_part_indexes"][i_shell]] \
                                                  if part_density[rr.arrays["element_shell_part_indexes"][i_shell]] != 0 else 0 \
                                                      for i_shell in range(0, rr.raw_header["nbFacets"])], shell_ids_tracker))
                    

        "Timestep Updates"
        timesteps.append(rr.arrays["timesteps"])
    
    "Assign the arrays to the D3PLOT class for writing"
    
    "Nodes"
    d3plot.arrays[ArrayType.node_acceleration]              = np.array(node_acceleration)
    d3plot.arrays[ArrayType.node_velocity]                  = np.array(node_velocity)
    d3plot.arrays[ArrayType.node_displacement]              = np.array(node_displacement)
    d3plot.arrays[ArrayType.node_coordinates]               = original_node_coordinates
    d3plot.arrays[ArrayType.node_ids]                       = sequential(rr.arrays["node_ids"])
    
    "Shells"    
    
    d3plot.arrays[ArrayType.element_shell_ids]              = apply_sorter(sequential(rr.arrays["element_shell_ids"]), shell_ids_tracker)
    d3plot.arrays[ArrayType.element_shell_node_indexes]     = apply_sorter(rr.arrays["element_shell_node_indexes"], shell_ids_tracker)
    d3plot.arrays[ArrayType.element_shell_part_indexes]     = apply_sorter(rr.arrays["element_shell_part_indexes"], shell_ids_tracker)

    v=np.array(rr.raw_arrays["pTextA"])
    
    shell_part_ids                                          =  np.array(rr.raw_arrays["pTextA"]).astype("U9").astype(int)
    
    shell_num = rr.raw_header["nbFacets"]
    shell_part_num = len(shell_part_ids)
    
    if element_shell_thickness != []:
        d3plot.arrays[ArrayType.element_shell_thickness]        = np.array(element_shell_thickness)
        d3plot.arrays[ArrayType.element_shell_internal_energy]  = np.array(element_shell_specific_energy)
    
    d3plot.arrays[ArrayType.element_shell_effective_plastic_strain] = np.zeros(shape=(states, rr.raw_header["nbFacets"], 2))
    
    d3plot.arrays[ArrayType.element_shell_is_alive]         = np.array(element_shell_is_alive)
    
    d3plot.arrays[ArrayType.element_shell_stress]           = np.array(element_shell_stress)
    
    "Beams"
    
    additional_beam_number                              = rr.raw_header["nbElts1D"] - len(rr.arrays["element_beam_part_indexes"])
    additional_beams                                    = np.zeros(shape=(additional_beam_number))
    additional_beams.fill(max(rr.arrays["element_beam_part_indexes"])+1)
    element_beam_part_indexes                           = np.concatenate([rr.arrays["element_beam_part_indexes"], additional_beams])
    
    #d3plot.arrays[ArrayType.element_beam_ids] = rr.arrays["element_beam_ids"]
    
    element_beam_node_indexes=np.zeros(shape=(rr.raw_header["nbElts1D"],5))
    
    element_beam_node_indexes[:,0]                      = rr.arrays["element_beam_node_indexes"][:,0]
    element_beam_node_indexes[:,1]                      = rr.arrays["element_beam_node_indexes"][:,1]
    d3plot.arrays[ArrayType.element_beam_node_indexes]  = element_beam_node_indexes.astype(int)
    d3plot.arrays[ArrayType.element_beam_part_indexes]  = element_beam_part_indexes.astype(int) + shell_part_num
    
    d3plot.arrays[ArrayType.element_beam_is_alive]      = np.array(element_beam_is_alive)
    
    
    #d3plot.arrays[ArrayType.element_beam_axial_force]  = d3.arrays["element_beam_axial_force"]
    #d3plot.arrays[ArrayType.element_beam_bending_moment] = d3.arrays["element_beam_bending_moment"]
    #d3plot.arrays[ArrayType.element_beam_shear_force] = d3.arrays["element_beam_shear_force"]
    #d3plot.arrays[ArrayType.element_beam_torsion_moment] = d3.arrays["element_beam_torsion_moment"]
    
    "Partless beams exists so we have to generate a dummy one 1000000000 - this could be improved"
    
    beam_part_ids                                       =   np.concatenate([np.array(rr.raw_arrays["pText1DA"])\
                                                                            .astype("U9").astype(int),\
                                                                                np.array([1000000000])])
    beam_part_num                                       = len(beam_part_ids)
  
    "Solids"
    
    d3plot.arrays[ArrayType.element_solid_node_indexes] = rr.arrays["element_solid_node_indexes"]
    d3plot.arrays[ArrayType.element_solid_part_indexes] = rr.arrays["element_solid_part_indexes"] + shell_part_num + beam_part_num
    
    d3plot.arrays[ArrayType.element_solid_is_alive]      = np.array(element_solid_is_alive)
    
    #d3plot.arrays[ArrayType.element_solid_effective_plastic_strain] = d3.arrays["element_solid_effective_plastic_strain"]
    #d3plot.arrays[ArrayType.element_solid_ids] = d3.arrays["element_solid_ids"]
    #d3plot.arrays[ArrayType.element_solid_node_indexes] = rr.arrays["element_solid_node_indexes"]
    #d3plot.arrays[ArrayType.element_solid_part_indexes] = rr.arrays["element_solid_part_indexes"]
    #d3plot.arrays[ArrayType.element_solid_stress] = np.zeros(shape=(states, rr.raw_header["nbElts3D"], 9))
    
    solid_part_ids                                      =  np.array(rr.raw_arrays["pText3DA"]).astype("U9").astype(int)
    
    "Global"
    #d3plot.arrays[ArrayType.global_internal_energy] = np.array([0] * states)
    #d3plot.arrays[ArrayType.global_kinetic_energy] = np.array([0] * states)
    #d3plot.arrays[ArrayType.global_total_energy] = np.array([0] * states)
    #d3plot.arrays[ArrayType.global_velocity] = np.array([[0, 0, 0]] * states).astype(float)
    
    "Parts"

    d3plot.arrays[ArrayType.part_ids]                   = np.concatenate([shell_part_ids, beam_part_ids, solid_part_ids])
    d3plot.arrays[ArrayType.part_mass]                  = np.array([np.concatenate([np.array(part_mass), np.zeros(shape=(rr.raw_header["nbParts1D"] + 1)), np.zeros(shape=(rr.raw_header["nbParts3D"]))])] * states)
    
    #d3plot.arrays[ArrayType.part_hourglass_energy]      = np.array([np.concatenate([np.array(part_mass), np.zeros(shape=(rr.raw_header["nbParts1D"] + 1)), np.zeros(shape=(rr.raw_header["nbParts3D"]))])] * states)
    #d3plot.arrays[ArrayType.part_ids_cross_references] = d3.arrays["part_ids_cross_references"]
    #d3plot.arrays[ArrayType.part_ids_unordered] = np.concatenate([shell_part_ids, beam_part_ids, solid_part_ids])
    #d3plot.arrays[ArrayType.part_internal_energy] = np.array([np.concatenate([np.array(part_mass), np.zeros(shape=(rr.raw_header["nbParts1D"] + 1)), np.zeros(shape=(rr.raw_header["nbParts3D"]))])] * states)
    
    #d3plot.arrays[ArrayType.part_kinetic_energy] = np.array([np.concatenate([np.array(part_mass), np.zeros(shape=(rr.raw_header["nbParts1D"] + 1)), np.zeros(shape=(rr.raw_header["nbParts3D"]))])] * states)
   
    #d3plot.arrays[ArrayType.part_titles] = np.array(np.concatenate([shell_part_ids, beam_part_ids, solid_part_ids])).astype('S')
    #d3plot.arrays[ArrayType.part_titles_ids] = np.concatenate([shell_part_ids, beam_part_ids, solid_part_ids])
    #d3plot.arrays[ArrayType.part_velocity] = np.array([np.concatenate([np.array(part_mass), np.zeros(shape=(rr.raw_header["nbParts1D"] + 1)), np.zeros(shape=(rr.raw_header["nbParts3D"]))])] * states)
    #d3plot.arrays[ArrayType.rigid_wall_force] = d3.arrays["rigid_wall_force"]
    
    d3plot.arrays[ArrayType.global_timesteps]           = np.array(timesteps)

    d3plot.write_d3plot(file_stem + ".d3plot", single_file = False)
     
    return True
        
if __name__ == '__main__':        
    
    file_stem = "D:\test\CamryOpenRadioss"
    
    out = A_2_D(file_stem)
